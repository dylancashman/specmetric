<html>
  <head>
    <script
      type="text/javascript"
      src="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.js"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/hyperformula/dist/hyperformula.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/underscore@1.13.6/underscore-umd-min.js"></script>
    <script
      src="https://code.jquery.com/jquery-3.7.1.js"
      integrity="sha256-eKhayi8LEQwp4NKxN+CfCh+3qOVUtJn3QNZ0TciWLP4="
      crossorigin="anonymous"
    ></script>
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/handsontable/dist/handsontable.full.min.css"
    />
  </head>

  <body>
    <div id="example"></div>
    <iframe
      id="iFrameID"
      style="width: 1200px; height: 700px; position: fixed; right: 100px;bottom: 100px; background: white"
      src="javascript:void(0);"
    ></iframe>
    <div
      id="generateVisMessage"
      style="width: 200px; height: 200px; position: fixed; right: 100px;top: 100px; background: white"
    >Highlight cell or cells of spreadsheet, and Press Ctrl to Generate Visualization</div>
    <script>
      const hf = HyperFormula.buildEmpty({
        licenseKey: "internal-use-in-handsontable",
      });

      const container = document.querySelector("#example");

      const columns = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N"];

      const logGroupDFG = (address) => {
        // We can handle 1-d vectors and 2-d vectors
        // But we don't use their equations, I don't think.
        // Maybe we can handle it, just interpret it as vec<x>
        // The question is, if there is a pattern in the equation
        // can we pattern match it, and of course we could, but
        // that's too much here.

        // Format for our address is
        // {start: {sheet: 0, col: startCol, row: startRow },
        //  end: {sheet: 0, col: endCol, row: endRow }}
        // We may want to throw away the headers somehow, or
        // deal with that on the backend

        // Need to check against the hyperformula format
        // We want to get the cell values, and send them back

        // we make sure to skip the first row, it is the header row
        // resulting in this ugly code
        const startAddr = address['start'];
        const endAddr = address['end'];
        let rangeValues = null;
        if (startAddr.row == -1) {
          rangeValues = hf.getRangeValues({
            start: { 
              sheet: startAddr.sheet, 
              col: startAddr.col,
              row: startAddr.row + 2
            },
            end: endAddr
          });
        } else {
          rangeValues = hf.getRangeValues(address);
        }

        const flatRangeValues = _.flatten(rangeValues);
        const datadict = {};
        const startAddrKey = columns[startAddr.col] + (startAddr.row + 1);
        const endAddrKey = columns[endAddr.col] + (endAddr.row + 1);
        const addrKey = startAddrKey + ": " + endAddrKey;
        
        datadict[String(addrKey)] = flatRangeValues;
        const node = {
          name: addrKey,
          parent: null,
          function: "vector",
          input_data: [],
          output_data: addrKey,
        };

        $.ajax({
          type: "POST",
          url: "/postSpecs",
          data: JSON.stringify({ nodes: [node], datadict, rootName: addrKey }),
          contentType: "application/json",

          success: function (response_data) {
            console.log("reloading iframe...");
            $.ajax({
              type: "GET",
              url: "/chart.html",
              success: function (htmlresponse) {
                document.getElementById("iFrameID").src =
                  "data:text/html;charset=utf-8," + escape(htmlresponse);
              },
            });
          },
          error: function () {
            console.log("request failed");
          },
        });
      }

      const logDFG = (address) => {
        const datadict = {};
        const nodes = [];
        const toVisit = [{ addr: address, parent: null }];
        let debugTimer = 0;
        let rootName = "";
        while (toVisit.length > 0 && debugTimer < 10) {
          // Load the node to send to the server
          debugTimer = debugTimer + 1;
          const visited = toVisit.shift();

          const visitVal = hf.getCellValue(visited.addr);

          const addrKey = columns[visited.addr.col] + (visited.addr.row + 1);
          datadict[String(addrKey)] = visitVal;
          const curr = {
            name: addrKey,
            parent: visited.parent,
            input_data: [],
            output_data: addrKey,
          };

          if (rootName.length < 1) {
            rootName = addrKey;
          }

          const hasFormula = hf.doesCellHaveFormula(visited.addr);
          if (hasFormula) {
            const formula = hf.getCellFormula(visited.addr);
            if (formula.includes("SUM")) {
              curr["function"] = "vector_sum";
              // Child is a vector
              // =SUM(C2:C5)

              curr["input_data"] = [formula.slice(4)];
            }
            if (formula.includes("AVERAGE")) {
              curr["function"] = "mean";
              // Child is a vector
              // =AVERAGE(C2:C5)

              curr["input_data"] = [formula.slice(8)];
            }
            if (formula.includes("COUNTIFS")) {
              curr["function"] = "countifs";
              // Child is a vector
              // =COUNTIFS(A2:A2001,E5,C2:C2001,"Yes")
              // =COUNTIFS(A2:A2001, E3)
              conditions = formula.slice(9);
              conditions = conditions.replace("(", "");
              conditions = conditions.replace(")", "");
              conditions = conditions.split(",");
              // curr["input_data"] = conditions;
              // We only want to record the source data as the input data, not the conditions, which are held in the odd slots
              curr["input_data"] = _.groupBy(conditions, (v,i) => (i % 2 == 1))
            }
            if (formula.includes("ROWS")) {
              curr["functions"] = "count";
              curr["input_data"] = formula.slice(5);
            }
            if (formula.includes("+")) {
              curr["function"] = "scalar_sum";
              // =B2-C2
              curr["input_data"] = [formula.slice(1, 3), formula.slice(4, 6)];
            }
            if (formula.includes("-")) {
              curr["function"] = "scalar_diff";
              curr["input_data"] = [formula.slice(1, 3), formula.slice(4, 6)];
            }
            if (formula.includes("/")) {
              curr["function"] = "scalar_ratio";
              curr["input_data"] = [formula.slice(1, 3), formula.slice(4, 6)];
            }
          } else {
            curr["function"] = "scalar";
          }

          nodes.push(curr);

          // BFS
          const precedents = hf.getCellPrecedents(visited.addr);
          if (["vector_sum", "mean", "countifs"].includes(curr["function"])) {
            const rangeVals = hf.getRangeValues(precedents[0]);
            const formattedVals = [];
            for (let j = 0; j < rangeVals.length; j++) {
              formattedVals[j] = rangeVals[j][0];
            }
            datadict[curr["input_data"]] = formattedVals;
            const childNode = {
              name: curr["input_data"],
              parent: curr.name,
              function: "vector",
              input_data: [],
              output_data: visitVal,
            };

            nodes.push(childNode);
          } else {
            let p;
            for (let i = 0; i < precedents.length; i++) {
              p = precedents[i];
              toVisit.push({ addr: p, parent: curr.name });
            }
          }

          console.log("nodes is ", nodes);

          $.ajax({
            type: "POST",
            url: "/postSpecs",
            data: JSON.stringify({ nodes, datadict, rootName }),
            contentType: "application/json",

            success: function (response_data) {
              console.log("reloading iframe...");
              $.ajax({
                type: "GET",
                url: "/chart.html",
                success: function (htmlresponse) {
                  document.getElementById("iFrameID").src =
                    "data:text/html;charset=utf-8," + escape(htmlresponse);
                },
              });
            },
            error: function () {
              console.log("request failed");
            },
          });
        }
      };

      const afterFormulasValuesUpdate = (changes) => {
        changes.forEach((change) => {
          console.log("change", change.address, change.newValue);

          console.log(
            "precedents",
            hf.getCellPrecedents({
              sheet: change.address.sheet,
              col: change.address.col,
              row: change.address.row,
            })
          );
        });
      };

      const whale = [
        ["Day", "Hazard Rate", "Change in %"],
        ["8/2", "8.0%", ""],
        ["8/3", "10.0%", "=B3-B2"],
        ["8/4", "13.0%", "=B4-B3"],
        ["8/5", "18.0%", "=B5-B4"],
        ["8/6", "13.0%", "=B6-B5"],
        ["8/7", "11.0%", "=B7-B6"],
        ["wrong", "$100/sum", "=100/sum(C3:C7)"],
        ["right", "$100/sum", "=100/(AVERAGE(C3:C7))"],
      ];
      const example = [
        ["Month", "Revenue", "Expense", "P/L"],
        ["Jan", 450, 200, ""],
        ["Feb", 300, 180, ""],
        ["Mar", 240, 230, ""],
        ["Apr", 350, 200, ""],
        ["May", 300, 110, ""],
        ["Jun", 240, 220, ""],
        ["Jul", 420, 100, ""],
        ["Aug", 400, 80, ""],
        ["Sep", 440, 330, ""],
        ["", "", "", ""],
      ];

      $.ajax({
        type: "GET",
        url: "/berkeley.csv",
        dataType: "text",

        success: function (berkeley_full) {
          var parsedBerkeleyFull = Papa.parse(berkeley_full);
          // console.log("parsedBerkeleyFull is ", parsedBerkeleyFull)
          const hot = new Handsontable(container, {
            // data: parsedBerkeleyFull.data,
            data: example,
            rowHeaders: true,
            colHeaders: true,
            formulas: {
              engine: hf,
              sheetName: "Sheet1",
            },
            // afterFormulasValuesUpdate,
            licenseKey: "non-commercial-and-evaluation", // for non-commercial use only
          });

          const logSelectedDFG = () => {
            const [[startRow, startCol, endRow, endCol]] = hot.getSelected();
            if (startRow == endRow && startCol == endCol) {
              logDFG({ sheet: 0, col: startCol, row: startRow });
            } else if (endRow > startRow || endCol > startCol) {
              logGroupDFG({ start: { sheet: 0, col: startCol, row: startRow}, end: { sheet: 0, col: endCol, row: endRow }});
            }
          };

          window.onkeydown = function (event) {
            if (event.ctrlKey) {
              // If 'ctrl' is pressed, visualize currently selected
              logSelectedDFG();
            }
          };
        },
        error: function () {
          console.log("berkeley request failed");
        },
      });

    </script>
  </body>
</html>
